= Additional Modifications
:experimental:
:imagesdir: images

=== 1. Adding a Role Check

There are numerous ways to handle authorization at different layers of your authenticated applications - one function available is to check *Roles*.

Roles identify a type or category of user. Admin, user, manager, and employee are all typical roles that may exist in an organization. Applications often assign access and permissions to specific roles rather than individual users as dealing with users can be too fine grained and hard to manage.

In this exercise we'll turn on a Role check in the Furever Home pet adoption service - this will ensure only responsible users are allowed to adopt a pet.

[NOTE]
====
Navigate back to your {{ ECLIPSE_CHE_URL }}[CodeReady Workspaces Terminal^] if you're not already in it.
====

First, we'll change the ConfigMap associated with the Furever Home frontend service - this will turn on the Role check.

Apply a reconfigured ConfigMap in the CodeReady Workspaces Terminal.  To find the edits made look for the two lines after `EDITS MADE HERE!`:

[source,sh,role="copypaste"]
----
cat <<EOF | oc apply -n {{ USER_ID}}-sso -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: furever-home-frontend-js-overrides
  labels:
    app: furever-home-frontend
    app.kubernetes.io/name: furever-home-frontend
    app.kubernetes.io/part-of: furever-home-frontend
    component: configmap
data:
  overrides.js: |
    var API_ENDPOINT = "https://furever-home-backend-{{ USER_ID}}-sso.${APPS_ROUTE_BASE}";
    var JUDGE_ENDPOINT = "https://furever-home-adoption-judge-usvc-{{ USER_ID}}-sso.${APPS_ROUTE_BASE}";
    var PROFILES_ENDPOINT = "https://pet-id-backend-{{ USER_ID}}-sso.${APPS_ROUTE_BASE}/app"
    var USER_ID = 1;
  functions.js: |
    console.log('hello from the functions file!');
  keycloak-shared.js: |
    function initKeycloak() {
      const KeycloakServer = "https://${RH_SSO_ROUTE}/auth/";
      const KeycloakRealm = "petcorp";
      const KeycloakClientID = "furever-home";
      let initOptions = {
        url: KeycloakServer, realm: KeycloakRealm, clientId: KeycloakClientID, onLoad: 'login-required'
      }
      var keycloak = new Keycloak(initOptions);
      keycloak.init({ onLoad: initOptions.onLoad }).then(function(authenticated) {
        if (authenticated) {
          username = keycloak.idTokenParsed.preferred_username;
          token = keycloak.token;
          USER_ID = keycloak.subject;
          realmRoles = keycloak.realmAccess;

          if (!realmRoles.roles.includes("responsible")) {
            // EDITS MADE HERE - the following two lines were uncommented!
            alert("You are not responsible enough to adopt a pet!");
            keycloak.logout();
          }

          jQuery(".text-username").text(username);
          // Query the Profiles API for the Avatar
          jQuery.ajax(PROFILES_ENDPOINT + '/profile?user_id=' + USER_ID, {
            success: function (data, status, xhr) {
              jsonO = JSON.parse(data);
              jsonI = jsonO.entities[0].profiles[0]
              jQuery("h1.h4 a.float-right").append('<img src="'+ jsonI.avatar_url +'" alt="Avatar" style="max-width: 60px;max-height: 60px;border-radius: 50%;margin: 0 0 0 1rem;" />');
            }
          });
          loadSubmissions();
        }
      }).catch(function(e) {
        console.log('failed to initialize');
        console.log(e);
      });
    }
  keycloak.json: |
    {
      "realm": "petcorp",
      "auth-server-url": "https://${RH_SSO_ROUTE}/auth/",
      "ssl-required": "none",
      "resource": "furever-home",
      "public-client": true,
      "confidential-port": 0
    }
EOF
----

Now the application is looking to see if the User has the `responsible` Role.  Let's add that Role to the Realm and associate a User with the Role to allow them to adopt a pet.

[NOTE]
====
Access the https://secure-sso-{{ USER_ID}}-sso.{{ ROUTE_SUBDOMAIN}}[Red Hat SSO Administrative Console^]

If you need to obtain the Administrative Username and Password just run the following:
====

[source,sh,role="copypaste"]
----
SSO_ADMIN_USER=$(oc get dc sso -n {{ USER_ID}}-sso -o jsonpath='{.spec.template.spec.containers[0].env}' | jq -r '.[] | select(.name | test("SSO_ADMIN_USERNAME")).value')
SSO_ADMIN_PASS=$(oc get dc sso -n {{ USER_ID}}-sso -o jsonpath='{.spec.template.spec.containers[0].env}' | jq -r '.[] | select(.name | test("SSO_ADMIN_PASSWORD")).value')

echo -e "\nAdmin User: ${SSO_ADMIN_USER}\nAdmin Pass: ${SSO_ADMIN_PASS}\n"
----

* Navigate in the left-hand pane to Roles.
* Click the *Add Role* button

image::rhsso_add_role.png[rhsso, 960]

* Add a Role with the name `responsible`

image::rhsso_add_responsible_role.png[rhsso, 960]

With the Role now created we can associate it with one of our users - assuming that the user `sadmin` is responsible enough, the system provides him the `responsible` Role!

* Navigate in the left-hand pane to Users.
* Click the *View All Users* button

image::rhsso_view_all_users.png[rhsso, 960]

* Select the *sadmin* user
* Click on the *Role Mappings* tab
* Select the `responsible` Role from the *Available Roles*
* Click the *Add selected >* button

image::rhsso_give_sadmin_responsible_role.png[rhsso, 960]

[NOTE]
====
Now you can log in as either user to see how the Role check allows or disallows pet adoption!
====

Go back to the {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-sso[Topology View^] to access the different front-end Routes.

=== 2. Adding Login Themes

One of the first things that is often changed is the theme!  If you are running RH SSO via a traditionally deployed JVM you simply add it to the file system - with a container you can bake custom images that include the assets, attach additional themes with ConfigMaps with assets in an S3 store, etc.

In this exercise we'll deploy a custom baked image with a Pet-tastic theme!

[NOTE]
====
Navigate back to your {{ ECLIPSE_CHE_URL }}[CodeReady Workspaces Terminal^] if you're not already in it.
====

First provide the DeploymentConfig a new ImageStream to pull from:

[source,sh,role="copypaste"]
----
oc set triggers dc/sso --from-image=openshift/sso74-openshift-rhel8:7.4-themed -c sso -n {{ USER_ID }}-sso
----

Then remove the old ImageStream trigger:

[source,sh,role="copypaste"]
----
oc set triggers dc/sso --from-image=openshift/sso74-openshift-rhel8:7.4 --remove -n {{ USER_ID }}-sso
----

The RH SSO Server will redeploy with the new themed container image.

[NOTE]
====
Access the https://secure-sso-{{ USER_ID}}-sso.{{ ROUTE_SUBDOMAIN}}[Red Hat SSO Administrative Console^]

You will need to reauthenticate - if you need to obtain the Administrative Username and Password just run the following:
====

[source,sh,role="copypaste"]
----
SSO_ADMIN_USER=$(oc get dc sso -n {{ USER_ID}}-sso -o jsonpath='{.spec.template.spec.containers[0].env}' | jq -r '.[] | select(.name | test("SSO_ADMIN_USERNAME")).value')
SSO_ADMIN_PASS=$(oc get dc sso -n {{ USER_ID}}-sso -o jsonpath='{.spec.template.spec.containers[0].env}' | jq -r '.[] | select(.name | test("SSO_ADMIN_PASSWORD")).value')

echo -e "\nAdmin User: ${SSO_ADMIN_USER}\nAdmin Pass: ${SSO_ADMIN_PASS}\n"
----

Next we'll change the Realm Themes:

* In the left-hand pane click *Realm Settings*
* Navigate to the *Themes* tab
* Change all the themes to `my-purrina`
* Click *Save*

image::rhsso_change_realm_themes.png[rhsso, 1100]

With the Realm Themes changed we can now change the Client Theme.

* In the left-hand pane, click *Clients*
* Click *Edit* next to the `pet-id` Client
* Change the *Login Theme* to `my-purrina`
* Click *Save*

image::rhsso_change_client_theme.png[rhsso, 1100]

[NOTE]
====
Repeat these steps for the `furever-home` Client
====

When reauthenticating as a user you should now see a different log in screen:

image::rhsso_custom_theme_login_screen.png[rhsso, 1100]

=== Congratulations!

You have now successfully begun to work with single sign-on technologies.  As a technology there are a vast array of controls and functions that are extended through the RH SSO platform and this is only the beginning - many of the deployments in this workshop are far from ideally secure and are meant just for simple demonstration purposes.

=== Summary

In this lab you learned a bit more about RH SSO and some of the supporting technologies and functions with OpenShift.

You deployed RH SSO, configured it with a basic Realm and components, deployed a few applications with a number of methods, and added additional customizations to the integrations.